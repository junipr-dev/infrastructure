#!/bin/bash
# Claude Auto-Session Wrapper
#
# Features:
# - Session tracking (writes session ID + transcript path to .current-session)
# - Manifest-based handoff detection
# - Session ID verification before killing
# - Auto-restart on context limit

LOG_FILE="$HOME/.claude/auto-session.log"
HANDOFF_DIR="$HOME/.claude/handoff"
SESSION_DIR="$HOME/.claude/projects"

# Per-wrapper-instance files (using PID for isolation between terminals)
WRAPPER_PID=$$
export CLAUDE_WRAPPER_PID=$$  # Export for statusline and hooks to identify this session
RESTART_FILE="$HOME/.claude/.restart-session-${WRAPPER_PID}"
KILLED_BY_MONITOR="$HOME/.claude/.killed-by-monitor-${WRAPPER_PID}"
CURRENT_SESSION_FILE="$HOME/.claude/.current-session-${WRAPPER_PID}"
WALL_DETECTED_FILE="$HOME/.claude/.wall-detected-${WRAPPER_PID}"
SIGHUP_EXIT_FILE="$HOME/.claude/.sighup-exit-${WRAPPER_PID}"

# Iteration tracking - changes each loop, subprocesses check this to know when to exit
ITERATION_FILE="$HOME/.claude/.iteration-${WRAPPER_PID}"
ITERATION_ID=0

# Legacy global file (still used for quick lookup by hooks)
WRAPPER_PID_FILE="$HOME/.claude/.wrapper-pid"

# Handoff ID from restart signal (ensures exact handoff is loaded)
FORCED_HANDOFF_ID=""

# Function to kill ALL background subprocesses from previous iterations
kill_iteration_subprocesses() {
    # Kill any subprocesses that were spawned by this wrapper
    # This catches verify_session, title_updater, monitor from previous iterations
    local children=$(pgrep -P $$ 2>/dev/null)
    for cpid in $children; do
        # Don't kill ourselves or the currently running Claude
        local cmd=$(ps -p "$cpid" -o comm= 2>/dev/null)
        [[ "$cmd" == "claude" ]] && continue
        [[ "$cmd" == "python3" ]] && continue  # pty-wrapper
        # Kill the subprocess and all its children
        pkill -P "$cpid" 2>/dev/null
        kill "$cpid" 2>/dev/null
    done
}

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$LOG_FILE"
}

find_claude() {
    for c in "$HOME/.local/bin/claude" "/usr/local/bin/claude" "/usr/bin/claude"; do
        [ -x "$c" ] && [ ! "$c" -ef "$0" ] && echo "$c" && return
    done
    command -v claude
}

CLAUDE_BIN=$(find_claude)
[ -z "$CLAUDE_BIN" ] && echo "ERROR: Cannot find claude" && exit 1

CLAUDE_DEFAULT_FLAGS="--dangerously-skip-permissions"

# PTY Wrapper for exit safety - intercepts Ctrl+C/D, /exit, /clear
PTY_WRAPPER="$HOME/.claude/bin/pty-wrapper.py"

# Function to launch Claude (through PTY wrapper if available)
launch_claude() {
    # PTY wrapper now supports resume mode with picker detection
    # It automatically switches to cooked mode when Claude's TUI picker is active
    if [ -x "$PTY_WRAPPER" ] && [ -t 0 ]; then
        # Use PTY wrapper for interactive sessions (including resume mode)
        log "Launching via PTY wrapper"
        python3 "$PTY_WRAPPER" "$@"
    else
        # Direct launch (non-interactive or PTY wrapper unavailable)
        log "Launching directly (no PTY wrapper)"
        "$@"
    fi
}

# Load shared libraries
source "$HOME/.claude/hooks/lib/get-channel.sh" 2>/dev/null || true
source "$HOME/.claude/hooks/lib/handoff-manifest.sh" 2>/dev/null || true

get_current_channel() {
    type get_channel &>/dev/null && get_channel "$1" || echo "global"
}

# Store our PID
echo $$ > "$WRAPPER_PID_FILE"

# Monitor PID will be set per-iteration
MONITOR_PID=""
CURRENT_SESSION_UUID=""

TITLE_UPDATER_PID=""
VERIFY_PID=""

cleanup() {
    # Restore terminal title
    printf '\033]0;%s\007' "$USER@$(hostname)"
    rm -f "$WRAPPER_PID_FILE"
    rm -f "$CURRENT_SESSION_FILE"
    rm -f "$RESTART_FILE" "$RESTART_FILE.dir"
    rm -f "$KILLED_BY_MONITOR"
    rm -f "$ITERATION_FILE"
    rm -f "$WALL_DETECTED_FILE"
    rm -f "$SIGHUP_EXIT_FILE"
    # Kill all background subprocesses
    kill_iteration_subprocesses
}

# Create handoff from current session (called by wrapper when wall detected)
# This runs AFTER Claude exits, so no hook timeout pressure
create_wall_handoff() {
    local channel="$1"
    local session_id="$2"
    local transcript="$3"

    log "Creating wall handoff for channel=$channel session=$session_id"

    # Source the libraries
    source "$HOME/.claude/hooks/lib/handoff-manifest.sh" 2>/dev/null || return 1
    source "$HOME/.claude/hooks/lib/extract-session-state.sh" 2>/dev/null || return 1

    # Check if handoff already exists
    if has_active_handoff "$channel"; then
        local existing_id=$(get_active_handoff_id "$channel")
        log "Handoff already exists: $existing_id"
        echo "$existing_id"
        return 0
    fi

    # Build and create handoff
    local content=$(build_handoff_content "$session_id" "$transcript" "$channel" "wall-hit" "100%")
    local handoff_id=$(create_handoff "$channel" "$content" "wall-hit")

    if [ -n "$handoff_id" ]; then
        log "Wall handoff created: $handoff_id"
        echo "$handoff_id"
        return 0
    else
        log "Failed to create wall handoff"
        return 1
    fi
}

# Update terminal title with current context percentage
# Runs in background, reads from session file (deterministic)
# SIMPLIFIED: No more resume mode transcript scanning - that caused cross-session bugs
start_title_updater() {
    local my_iteration="$ITERATION_ID"
    local iteration_file="$ITERATION_FILE"
    local expected_transcript="$EXPECTED_TRANSCRIPT"
    local session_file="$CURRENT_SESSION_FILE"
    (
        local last_percent=-1
        while true; do
            sleep 1

            # Exit if iteration has changed (wrapper looped/restarted)
            local current_iteration=$(cat "$iteration_file" 2>/dev/null)
            [ "$current_iteration" != "$my_iteration" ] && exit 0

            # Read transcript from session file (may be updated by resume mode)
            local transcript=""
            if [ -f "$session_file" ]; then
                transcript=$(cut -d: -f2 "$session_file" 2>/dev/null)
            fi
            [ -z "$transcript" ] && transcript="$expected_transcript"

            if [ -n "$transcript" ] && [ -f "$transcript" ]; then
                local tokens=$(strings "$transcript" 2>/dev/null | \
                    grep "cache_read_input_tokens" | \
                    tail -1 | \
                    grep -oE '"cache_read_input_tokens":[0-9]+' | \
                    cut -d: -f2)

                if [ -n "$tokens" ] && [ "$tokens" -gt 0 ]; then
                    local percent=$((tokens * 100 / 200000))
                    # Only update if changed (reduces flicker)
                    if [ "$percent" != "$last_percent" ]; then
                        last_percent=$percent
                        if [ "$percent" -ge 96 ]; then
                            printf '\033]0;Claude [%d%% CRIT]\007' "$percent"
                        elif [ "$percent" -ge 90 ]; then
                            printf '\033]0;Claude [%d%% WARN]\007' "$percent"
                        else
                            printf '\033]0;Claude [%d%%]\007' "$percent"
                        fi
                    fi
                else
                    printf '\033]0;Claude [0%%]\007'
                fi
            else
                printf '\033]0;Claude [0%%]\007'
            fi
        done
    ) &
    TITLE_UPDATER_PID=$!
}
trap cleanup EXIT

# Function to track active session in RESUME MODE ONLY
# In normal mode: NOT CALLED - session is predetermined
# In resume mode: detects which session the user picked (ONE TIME, not continuous)
verify_session_resume() {
    local my_iteration="$ITERATION_ID"
    local iteration_file="$ITERATION_FILE"
    local wrapper_pid=$$
    local session_file="$CURRENT_SESSION_FILE"
    local project_dir="$1"  # MUST pass specific project dir to avoid global scanning
    (
        log "verify_session_resume started for wrapper $wrapper_pid, iteration $my_iteration, project=$project_dir"

        local detected=false
        local attempts=0
        local max_attempts=30  # Wait up to 60 seconds for user to pick

        while [ "$detected" = false ] && [ $attempts -lt $max_attempts ]; do
            sleep 2
            attempts=$((attempts + 1))

            # Exit if iteration has changed (wrapper looped/restarted)
            local current_iteration=$(cat "$iteration_file" 2>/dev/null)
            [ "$current_iteration" != "$my_iteration" ] && exit 0

            # CRITICAL FIX: Only scan transcripts in THIS specific project directory
            # NOT the global SESSION_DIR - that was the bug!
            if [ -n "$project_dir" ] && [ -d "$project_dir" ]; then
                # Find transcripts modified in last 30 seconds IN THIS PROJECT ONLY
                local active_transcript=$(find "$project_dir" -maxdepth 1 -name "*.jsonl" -mmin -0.5 2>/dev/null | head -1)
                if [ -n "$active_transcript" ] && [ -f "$active_transcript" ]; then
                    # Extract session ID from transcript filename
                    local detected_session=$(basename "$active_transcript" .jsonl)
                    # Update session file with detected info
                    echo "${detected_session}:${active_transcript}:${wrapper_pid}" > "$session_file"
                    log "Resume mode: detected session $detected_session in $project_dir"
                    detected=true
                fi
            fi
        done

        if [ "$detected" = false ]; then
            log "Resume mode: no session detected after $max_attempts attempts"
        fi
    ) &
    VERIFY_PID=$!
}

# Function to start monitor subprocess
start_monitor() {
    local MY_WRAPPER_PID=$$
    local my_iteration="$ITERATION_ID"
    local iteration_file="$ITERATION_FILE"
    local restart_file="$RESTART_FILE"
    local killed_file="$KILLED_BY_MONITOR"
    local session_file="$CURRENT_SESSION_FILE"
    local pid_file="$WRAPPER_PID_FILE"

    (
        while true; do
            sleep 0.25

            # Exit if iteration has changed (wrapper looped/restarted)
            local current_iteration=$(cat "$iteration_file" 2>/dev/null)
            [ "$current_iteration" != "$my_iteration" ] && exit 0

            # Safety: Exit if our wrapper is dead
            if ! kill -0 "$MY_WRAPPER_PID" 2>/dev/null; then
                exit 0
            fi

            [ ! -f "$pid_file" ] && exit 0

            # Safety: Only act if WE are still the current wrapper
            local current_wrapper=$(cat "$pid_file" 2>/dev/null)
            if [ "$current_wrapper" != "$MY_WRAPPER_PID" ]; then
                exit 0
            fi

            # Only check PID-specific restart signal
            if [ -f "$restart_file" ]; then
                # Read restart signal (format: SESSION_ID:WORKING_DIR:HANDOFF_ID)
                local signal_content=$(cat "$restart_file" 2>/dev/null)
                local signal_session=$(echo "$signal_content" | cut -d: -f1)
                local signal_dir=$(echo "$signal_content" | cut -d: -f2)

                # Verify session ID if we have one tracked
                if [ -f "$session_file" ]; then
                    local tracked_session=$(cut -d: -f1 "$session_file" 2>/dev/null)
                    # Skip session verification if in resume mode (RESUME_PENDING)
                    if [ "$tracked_session" != "RESUME_PENDING" ] && [ -n "$signal_session" ] && [ -n "$tracked_session" ] && [ "$signal_session" != "$tracked_session" ]; then
                        log "Monitor: Session mismatch - signal:$signal_session tracked:$tracked_session - ignoring"
                        rm -f "$restart_file"
                        continue
                    fi
                fi

                local my_pid=$BASHPID
                # Find Claude (child of wrapper that isn't this monitor subprocess)
                local claude_pid=$(pgrep -P "$MY_WRAPPER_PID" 2>/dev/null | grep -v "^${my_pid}$" | head -1)
                if [ -n "$claude_pid" ]; then
                    log "Monitor: Killing Claude PID $claude_pid (session: $signal_session)"
                    touch "$killed_file"
                    [ -n "$signal_dir" ] && echo "$signal_dir" > "${restart_file}.dir"
                    kill -TERM "$claude_pid" 2>/dev/null
                    sleep 0.2
                    kill -9 "$claude_pid" 2>/dev/null
                fi
                exit 0
            fi
        done
    ) &
    MONITOR_PID=$!
}

# Check for flags
# RESUME_MODE: User wants Claude's native session picker (not handoff system)
# USER_WANTS_HANDOFF: User wants to load a specific handoff file
# EXPLICIT_HANDOFF_ID: The specific handoff ID to load (required with -h)
RESUME_MODE=false
USER_WANTS_HANDOFF=false
EXPLICIT_HANDOFF_ID=""
FILTERED_ARGS=()

# Parse arguments with explicit handoff ID support
while [ $# -gt 0 ]; do
    case "$1" in
        -r|-c|--resume|--continue)
            RESUME_MODE=true
            export CLAUDE_RESUME_MODE=true  # Export for hooks to detect
            FILTERED_ARGS+=("$1")  # Pass through for native picker
            shift
            ;;
        -h|--handoff)
            # -h requires an explicit handoff ID now
            if [ -z "$2" ] || [[ "$2" == -* ]]; then
                echo "Error: -h requires a handoff ID"
                echo "Usage: claude -h HO-YYYYMMDD-HHMMSS-xxxxx"
                echo ""
                echo "To see available handoffs:"
                echo "  ls ~/.claude/handoff/*.manifest.json"
                exit 1
            fi
            USER_WANTS_HANDOFF=true
            EXPLICIT_HANDOFF_ID="$2"
            shift 2
            ;;
        *)
            FILTERED_ARGS+=("$1")
            shift
            ;;
    esac
done

RESTART_COUNT=0
MAX_RESTARTS=10
WORKING_DIR="${PWD}"
SIGHUP_CLOSE_TAB=false

log "=== Wrapper $$ started in $WORKING_DIR ==="

while true; do
    # Record this iteration's start time
    ITERATION_START=$(date +%s)

    # INCREMENT ITERATION ID - this tells old subprocesses to exit
    ITERATION_ID=$((ITERATION_ID + 1))
    echo "$ITERATION_ID" > "$ITERATION_FILE"

    # KILL ALL BACKGROUND SUBPROCESSES from previous iterations
    # This is a safety net - they should exit when they see iteration changed,
    # but we force-kill in case they're stuck in sleep
    kill_iteration_subprocesses

    # Clean up signals and trigger locks from previous iterations
    rm -f "$RESTART_FILE" "$RESTART_FILE.dir" "$KILLED_BY_MONITOR"
    rm -f "$HOME/.claude/.critical-triggered-"* 2>/dev/null
    rm -f "$CURRENT_SESSION_FILE"

    CHANNEL=$(get_current_channel "$WORKING_DIR")
    log "Channel: $CHANNEL, Restart #$RESTART_COUNT, Iteration #$ITERATION_ID"

    # Generate session UUID UPFRONT - no guessing needed
    # This is the key to bulletproof session tracking
    project_path=$(pwd | sed 's|/|-|g')
    project_dir="$SESSION_DIR/$project_path"
    CURRENT_SESSION_UUID=$(cat /proc/sys/kernel/random/uuid)
    EXPECTED_TRANSCRIPT="$project_dir/${CURRENT_SESSION_UUID}.jsonl"
    export CURRENT_SESSION_UUID EXPECTED_TRANSCRIPT

    # Write session file IMMEDIATELY - before Claude even starts
    # Claude will create the transcript with this UUID via --session-id
    echo "${CURRENT_SESSION_UUID}:${EXPECTED_TRANSCRIPT}:$$" > "$CURRENT_SESSION_FILE"
    log "Session ID: $CURRENT_SESSION_UUID"

    # Start fresh monitor for this Claude instance
    start_monitor
    log "Monitor PID: $MONITOR_PID"

    # Start terminal title updater (shows context % in terminal title)
    start_title_updater

    # ==========================================================================
    # HANDOFF OWNERSHIP: Set CLAUDE_LOAD_HANDOFF based on intent
    # ==========================================================================
    # This env var tells the session-start hook whether to load a handoff:
    #   - "auto:{handoff_id}" = Auto-restart from context monitor (load specific handoff)
    #   - "manual" = User explicitly requested handoff via -h flag
    #   - (unset) = Fresh start or resume - do NOT auto-consume handoffs
    #
    # Note: RESUME_MODE (-r/-c) does NOT set CLAUDE_LOAD_HANDOFF because we're
    # loading an existing session, not a handoff. Handoffs are a fallback.
    # ==========================================================================
    if [ $RESTART_COUNT -gt 0 ] && [ -n "$FORCED_HANDOFF_ID" ]; then
        # Auto-restart from context monitor - load the specific handoff
        export CLAUDE_LOAD_HANDOFF="auto:${FORCED_HANDOFF_ID}"
        log "CLAUDE_LOAD_HANDOFF=auto:${FORCED_HANDOFF_ID}"
    elif [ "$USER_WANTS_HANDOFF" = true ]; then
        # User explicitly requested handoff via -h/--handoff
        export CLAUDE_LOAD_HANDOFF="manual"
        log "CLAUDE_LOAD_HANDOFF=manual"
    else
        # Fresh start or resume - explicitly unset to prevent accidental handoff consumption
        unset CLAUDE_LOAD_HANDOFF
        log "CLAUDE_LOAD_HANDOFF=(unset - fresh start or resume)"
    fi

    # Run Claude - method depends on mode
    if [ $RESTART_COUNT -eq 0 ]; then
        # First start
        if [ "$RESUME_MODE" = true ]; then
            # =================================================================
            # RESUME MODE: Use Claude's native session picker
            # =================================================================
            # Don't pass --session-id - it conflicts with -r/-c
            # verify_session_resume will detect which session the user picks.
            # CRITICAL: Pass the specific project_dir to prevent global scanning!
            # =================================================================
            log "Starting in RESUME MODE (native picker, project_dir=$project_dir)"

            # Write placeholder session file (will be updated by verify_session_resume)
            echo "RESUME_PENDING::$$" > "$CURRENT_SESSION_FILE"

            # Start session verifier ONLY FOR RESUME MODE
            # Pass the specific project directory to prevent cross-session contamination
            verify_session_resume "$project_dir" 2>/dev/null

            # Background task: clean up safety handoff after successful resume
            _resume_iteration="$ITERATION_ID"
            _resume_iteration_file="$ITERATION_FILE"
            (
                sleep 3
                # Exit if iteration changed
                [ "$(cat "$_resume_iteration_file" 2>/dev/null)" != "$_resume_iteration" ] && exit 0
                # Check if Claude is still running (wrapper still has a child)
                if pgrep -P $$ >/dev/null 2>&1; then
                    # Resume succeeded - clean up any safety handoff for this channel
                    if type has_active_handoff &>/dev/null && has_active_handoff "$CHANNEL"; then
                        _cleanup_id=$(get_active_handoff_id "$CHANNEL")
                        log "Resume succeeded - archiving safety handoff $_cleanup_id"
                        type clear_handoff &>/dev/null && clear_handoff "$CHANNEL"
                    fi
                fi
            ) &

            # Launch Claude with native resume (no --session-id)
            launch_claude $CLAUDE_BIN $CLAUDE_DEFAULT_FLAGS "${FILTERED_ARGS[@]}"

        elif [ "$USER_WANTS_HANDOFF" = true ]; then
            # =================================================================
            # HANDOFF MODE: Load a specific handoff by ID
            # =================================================================
            # User ran: claude -h HO-20260205-143000-abc123
            # We load that EXACT handoff, not just any available one
            # =================================================================

            # Find the handoff file - check current and archive
            HANDOFF_FILE=""
            for manifest in "$HANDOFF_DIR"/*.manifest.json; do
                [ ! -f "$manifest" ] && continue
                if grep -q "\"id\":.*\"$EXPLICIT_HANDOFF_ID\"" "$manifest" 2>/dev/null; then
                    _manifest_channel=$(basename "$manifest" .manifest.json)
                    HANDOFF_FILE="$HANDOFF_DIR/${_manifest_channel}-CURRENT.md"
                    break
                fi
            done

            # Check archive if not found in current
            if [ -z "$HANDOFF_FILE" ] || [ ! -f "$HANDOFF_FILE" ]; then
                HANDOFF_FILE="$HANDOFF_DIR/archive/${EXPLICIT_HANDOFF_ID}.md"
            fi

            if [ -f "$HANDOFF_FILE" ]; then
                log "Loading explicit handoff: $EXPLICIT_HANDOFF_ID from $HANDOFF_FILE"
                export CLAUDE_LOAD_HANDOFF="manual:${EXPLICIT_HANDOFF_ID}"
                launch_claude $CLAUDE_BIN $CLAUDE_DEFAULT_FLAGS --session-id "$CURRENT_SESSION_UUID" "Continue from handoff ${EXPLICIT_HANDOFF_ID}. The handoff should be auto-loaded by the session hook. If not, read $HANDOFF_FILE"
            else
                echo "Error: Handoff $EXPLICIT_HANDOFF_ID not found"
                echo ""
                echo "Available handoffs:"
                for manifest in "$HANDOFF_DIR"/*.manifest.json; do
                    [ ! -f "$manifest" ] && continue
                    _hid=$(grep -oP '"id":\s*"\K[^"]+' "$manifest" 2>/dev/null | head -1)
                    [ -n "$_hid" ] && echo "  $_hid"
                done
                exit 1
            fi
        else
            # =================================================================
            # NORMAL MODE: Fresh start with pre-determined session ID
            # =================================================================
            log "Starting fresh with session $CURRENT_SESSION_UUID"
            launch_claude $CLAUDE_BIN $CLAUDE_DEFAULT_FLAGS --session-id "$CURRENT_SESSION_UUID" "${FILTERED_ARGS[@]}"
        fi
    else
        # Auto-restart - handoff should exist from pre-compact hook

        # Check for handoff - prefer FORCED_HANDOFF_ID from restart signal
        HANDOFF_FILE=""
        HANDOFF_ID=""

        if [ -n "$FORCED_HANDOFF_ID" ]; then
            # Use the EXACT handoff ID from the restart signal (robust/infallible)
            HANDOFF_ID="$FORCED_HANDOFF_ID"
            HANDOFF_FILE="$HOME/.claude/handoff/${CHANNEL}-CURRENT.md"
            # Verify the file exists and contains this handoff ID
            if [ -f "$HANDOFF_FILE" ] && grep -q "$FORCED_HANDOFF_ID" "$HANDOFF_FILE" 2>/dev/null; then
                log "Using forced handoff ID from signal: $HANDOFF_ID"
            else
                # Handoff file might have been archived - check archive
                ARCHIVED_FILE="$HOME/.claude/handoff/archive/${FORCED_HANDOFF_ID}.md"
                if [ -f "$ARCHIVED_FILE" ]; then
                    HANDOFF_FILE="$ARCHIVED_FILE"
                    log "Using archived handoff: $HANDOFF_ID"
                else
                    log "WARNING: Forced handoff $FORCED_HANDOFF_ID not found!"
                    HANDOFF_FILE=""
                    HANDOFF_ID=""
                fi
            fi
            # Clear for next iteration
            FORCED_HANDOFF_ID=""
        elif type has_active_handoff &>/dev/null && has_active_handoff "$CHANNEL"; then
            # Fallback to channel-based lookup
            HANDOFF_FILE=$(get_active_handoff_file "$CHANNEL")
            HANDOFF_ID=$(get_active_handoff_id "$CHANNEL")
        fi

        if [ -n "$HANDOFF_FILE" ]; then
            HANDOFF_PROMPT="Continue from handoff (ID: $HANDOFF_ID). The handoff should be auto-loaded by the session hook. Continue the task from where we left off."
            log "Restarting with handoff: $HANDOFF_ID"
        else
            HANDOFF_PROMPT="Continue from handoff. Check memory-keeper for recent context and continue where we left off."
            log "Restarting (no handoff found for channel: $CHANNEL)"
        fi

        # Show brief warning, then clear and restart
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "  ðŸ”„ AUTO-HANDOFF: Context at wall - restarting..."
        echo "  ðŸ“ Channel: $CHANNEL"
        [ -n "$HANDOFF_ID" ] && echo -e "  ðŸ“‹ Handoff: \033[1;34mclaude -h $HANDOFF_ID\033[0m"
        echo "  â³ Restarting in 2 seconds..."
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        sleep 2
        # Clear screen and scrollback
        printf '\033[2J\033[3J\033[H'
        # Session UUID was already generated at loop start
        log "Restarting with session: $CURRENT_SESSION_UUID"
        launch_claude $CLAUDE_BIN $CLAUDE_DEFAULT_FLAGS --session-id "$CURRENT_SESSION_UUID" "$HANDOFF_PROMPT"
    fi
    EXIT_CODE=$?
    log "Claude exited: $EXIT_CODE"

    # =========================================================================
    # WALL DETECTION: Check if PTY wrapper detected a wall hit
    # =========================================================================
    # If wall detected, create handoff NOW (no hook timeout pressure) and restart
    # =========================================================================
    if [ -f "$WALL_DETECTED_FILE" ]; then
        log "Wall detected by PTY wrapper - creating handoff"
        rm -f "$WALL_DETECTED_FILE"

        # Read session info
        if [ -f "$CURRENT_SESSION_FILE" ]; then
            _wall_session_info=$(cat "$CURRENT_SESSION_FILE" 2>/dev/null)
            _wall_session_id=$(echo "$_wall_session_info" | cut -d: -f1)
            _wall_transcript=$(echo "$_wall_session_info" | cut -d: -f2)
        else
            _wall_session_id="$CURRENT_SESSION_UUID"
            _wall_transcript="$EXPECTED_TRANSCRIPT"
        fi

        # Create handoff (runs after Claude exit, no timeout pressure)
        WALL_HANDOFF_ID=$(create_wall_handoff "$CHANNEL" "$_wall_session_id" "$_wall_transcript")

        if [ -n "$WALL_HANDOFF_ID" ]; then
            log "Wall handoff created: $WALL_HANDOFF_ID - triggering restart"

            # Show user message
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "  ðŸ§± WALL HIT: Context at 100%"
            echo "  ðŸ“ Channel: $CHANNEL"
            echo -e "  ðŸ“‹ Handoff: \033[1;34mclaude -h $WALL_HANDOFF_ID\033[0m"
            echo "  ðŸ”„ Auto-restarting..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

            # Set up for restart
            FORCED_HANDOFF_ID="$WALL_HANDOFF_ID"
            RESTART_COUNT=$((RESTART_COUNT + 1))

            if [ $RESTART_COUNT -ge $MAX_RESTARTS ]; then
                echo "Max restarts reached"
                exit 1
            fi

            # Clear screen before restart
            sleep 1
            printf '\033[2J\033[3J\033[H'

            # Continue to next iteration (restart)
            continue
        else
            log "Failed to create wall handoff - normal exit"
        fi
    fi

    # Clear session tracking
    rm -f "$CURRENT_SESSION_FILE"

    # =========================================================================
    # SIGHUP DETECTION: Tab close / SSH disconnect
    # =========================================================================
    # If PTY wrapper detected SIGHUP (terminal closed), exit cleanly and close tab
    # No handoff - transcript preserved for `claude -r`
    # =========================================================================
    if [ -f "$SIGHUP_EXIT_FILE" ]; then
        log "SIGHUP detected by PTY wrapper - clean exit, closing tab"
        rm -f "$SIGHUP_EXIT_FILE"
        rm -f "$RESTART_FILE" "$RESTART_FILE.dir" "$KILLED_BY_MONITOR"

        # Don't break yet - fall through to close-tab logic after loop
        # Set a flag to trigger tab close
        SIGHUP_CLOSE_TAB=true
        break
    fi

    # Exit code 130 = SIGINT (Ctrl+C) - user wants to quit, never restart
    if [ $EXIT_CODE -eq 130 ]; then
        log "User pressed Ctrl+C - clean exit, no restart"
        rm -f "$RESTART_FILE" "$RESTART_FILE.dir" "$KILLED_BY_MONITOR"
        break
    fi

    # Only restart if MONITOR killed Claude (not user Ctrl+C)
    if [ -f "$KILLED_BY_MONITOR" ]; then
        rm -f "$KILLED_BY_MONITOR"

        if [ -f "$RESTART_FILE" ] || [ -f "$RESTART_FILE.dir" ]; then
            # Parse restart signal - new format: SESSION_ID:WORKING_DIR:HANDOFF_ID
            SIGNAL_CONTENT=$(cat "$RESTART_FILE" 2>/dev/null)
            SIGNAL_DIR=""
            SIGNAL_HANDOFF_ID=""

            if [ -f "$RESTART_FILE.dir" ]; then
                SIGNAL_DIR=$(cat "$RESTART_FILE.dir" 2>/dev/null)
            elif [ -n "$SIGNAL_CONTENT" ]; then
                # Parse fields from signal
                SIGNAL_DIR=$(echo "$SIGNAL_CONTENT" | cut -d: -f2)
                SIGNAL_HANDOFF_ID=$(echo "$SIGNAL_CONTENT" | cut -d: -f3)
            fi

            log "Auto-restart triggered (monitor killed session)"
            [ -n "$SIGNAL_HANDOFF_ID" ] && log "Signal handoff ID: $SIGNAL_HANDOFF_ID"
            rm -f "$RESTART_FILE" "$RESTART_FILE.dir"

            [ -n "$SIGNAL_DIR" ] && [ -d "$SIGNAL_DIR" ] && WORKING_DIR="$SIGNAL_DIR" && cd "$WORKING_DIR"

            # Store handoff ID for use in restart logic
            FORCED_HANDOFF_ID="$SIGNAL_HANDOFF_ID"

            RESTART_COUNT=$((RESTART_COUNT + 1))
            [ $RESTART_COUNT -ge $MAX_RESTARTS ] && echo "Max restarts reached" && exit 1

            # Extra cleanup before restart to prevent stale signals
            rm -f "$RESTART_FILE" "$RESTART_FILE.dir" "$KILLED_BY_MONITOR"
            continue
        fi
    fi

    # Clean exit - don't restart
    rm -f "$RESTART_FILE" "$RESTART_FILE.dir"  # Clean up any stale signal

    # Check for active handoff to notify user
    if type has_active_handoff &>/dev/null && has_active_handoff "$CHANNEL"; then
        HANDOFF_FILE=$(get_active_handoff_file "$CHANNEL")
        HANDOFF_ID=$(get_active_handoff_id "$CHANNEL")
        echo -e "Handoff available: \033[1;34mclaude -h $HANDOFF_ID\033[0m"
    fi

    log "Clean exit"
    break
done

log "=== Wrapper finished ==="

# =============================================================================
# CHECK FOR CLOSE-TAB SIGNAL
# =============================================================================
# Close tab on:
# - /bye or /discard (close-tab signal file)
# - SIGHUP (tab close / SSH disconnect)
# We close the terminal by killing the parent shell process.
# =============================================================================
CLOSE_TAB_SIGNAL="$HOME/.claude/signals/close-tab-$$"
CLOSE_TAB_SIGNAL_LEGACY="$HOME/.claude/signals/close-tab"
SHOULD_CLOSE_TAB=false

if [ -f "$CLOSE_TAB_SIGNAL" ] || [ -f "$CLOSE_TAB_SIGNAL_LEGACY" ]; then
    rm -f "$CLOSE_TAB_SIGNAL" "$CLOSE_TAB_SIGNAL_LEGACY"
    log "Close-tab signal file detected"
    SHOULD_CLOSE_TAB=true
fi

if [ "$SIGHUP_CLOSE_TAB" = true ]; then
    log "SIGHUP close-tab flag set"
    SHOULD_CLOSE_TAB=true
fi

if [ "$SHOULD_CLOSE_TAB" = true ]; then
    log "Closing terminal tab"

    # Get the shell that started this wrapper (our parent)
    PARENT_SHELL_PID=$PPID

    # Safety check: only kill if parent is a shell
    PARENT_CMD=$(ps -p "$PARENT_SHELL_PID" -o comm= 2>/dev/null)
    if [[ "$PARENT_CMD" =~ ^(bash|zsh|sh|fish)$ ]]; then
        # Small delay to let any final output display
        sleep 0.3
        # Kill parent shell - this closes the terminal tab
        kill -9 "$PARENT_SHELL_PID" 2>/dev/null
    else
        log "Parent is not a shell ($PARENT_CMD) - not closing tab"
    fi
fi

exit $EXIT_CODE
